<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Nature Sounds Synth</title>
<style>
  :root {
    --bg1: #0b1020;
    --bg2: #182642;
    --accent: #7fd1ff;
    --accent-soft: rgba(127, 209, 255, 0.2);
    --text-main: #f7f9ff;
    --text-muted: #aab3d1;
    --card-bg: rgba(9, 14, 30, 0.9);
    --border-subtle: rgba(255, 255, 255, 0.08);
    --danger: #ff6b6b;
    --success: #12b886;
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    padding: 0;
    min-height: 100vh;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
                 "Segoe UI", sans-serif;
    color: var(--text-main);
    background: radial-gradient(circle at top, var(--bg2), var(--bg1) 60%);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1.5rem;
    line-height: 1.5;
  }

  .app {
    width: 100%;
    max-width: 980px;
    padding: 1.5rem 1.75rem 1.75rem;
    border-radius: 24px;
    background: var(--card-bg);
    border: 1px solid var(--border-subtle);
    box-shadow:
      0 24px 60px rgba(0, 0, 0, 0.55),
      0 0 0 1px rgba(255, 255, 255, 0.02);
    backdrop-filter: blur(18px);
  }

  header {
    text-align: center;
    margin-bottom: 1.25rem;
  }

  header h1 {
    font-size: 1.6rem;
    margin: 0;
    letter-spacing: 0.03em;
    color: var(--text-main);
  }

  header p {
    margin: 0.35rem 0 0;
    font-size: 0.95rem;
    color: var(--text-muted);
  }

  .row {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    align-items: center;
    margin: 10px 0;
  }

  button {
    border: none;
    outline: none;
    border-radius: 999px;
    padding: 0.65rem 1.5rem;
    font-size: 0.95rem;
    font-weight: 600;
    letter-spacing: 0.05em;
    cursor: pointer;
    transition:
      transform 0.12s ease-out,
      box-shadow 0.12s ease-out,
      background 0.12s ease-out;
  }

  button#btnPlay {
    background: radial-gradient(circle at top, #2c74ff, #2852ff);
    color: white;
    box-shadow:
      0 12px 28px rgba(33, 90, 255, 0.65),
      0 0 0 1px rgba(255, 255, 255, 0.08);
  }

  button#btnPlay:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow:
      0 16px 40px rgba(33, 90, 255, 0.78),
      0 0 0 1px rgba(255, 255, 255, 0.1);
  }

  button#btnPlay.playing {
    background: radial-gradient(circle at top, #12b886, #0a996d);
    box-shadow:
      0 14px 32px rgba(16, 192, 134, 0.75),
      0 0 0 1px rgba(255, 255, 255, 0.1);
  }

  button#btnStop {
    background: rgba(255, 255, 255, 0.1);
    color: var(--text-main);
    border: 1px solid var(--border-subtle);
  }

  button#btnStop:hover:not(:disabled) {
    background: rgba(255, 255, 255, 0.15);
    transform: translateY(-1px);
  }

  button#btnRandom {
    background: rgba(255, 255, 255, 0.05);
    color: var(--text-main);
    border: 1px solid var(--border-subtle);
    font-size: 0.85rem;
    padding: 0.5rem 1.2rem;
  }

  button#btnRandom:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: var(--accent-soft);
  }

  button:active:not(:disabled) {
    transform: translateY(1px) scale(0.98);
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  select {
    padding: 0.5rem 0.75rem;
    border-radius: 8px;
    border: 1px solid var(--border-subtle);
    background: rgba(255, 255, 255, 0.05);
    color: var(--text-main);
    font-size: 0.9rem;
    cursor: pointer;
    outline: none;
    transition: border-color 0.12s ease-out, background 0.12s ease-out;
  }

  select:hover {
    border-color: var(--accent-soft);
    background: rgba(255, 255, 255, 0.08);
  }

  select:focus {
    border-color: var(--accent);
  }

  label {
    color: var(--text-muted);
    font-size: 0.9rem;
  }

  .card {
    border: 1px solid var(--border-subtle);
    border-radius: 16px;
    padding: 1.25rem;
    background: rgba(0, 0, 0, 0.2);
    margin-bottom: 1rem;
  }

  .grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
  }

  @media (max-width: 800px) {
    .grid {
      grid-template-columns: 1fr;
    }
  }

  .ctrl {
    display: grid;
    grid-template-columns: 140px 1fr 60px;
    gap: 10px;
    align-items: center;
    margin-bottom: 0.75rem;
  }

  .ctrl label {
    font-size: 0.85rem;
    color: var(--text-muted);
  }

  .ctrl span {
    font-size: 0.8rem;
    color: var(--text-muted);
    font-variant-numeric: tabular-nums;
    text-align: right;
  }

  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 4px;
    border-radius: 999px;
    background: linear-gradient(90deg, var(--accent-soft), rgba(255,255,255,0.04));
    outline: none;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #ffffff;
    border: 2px solid var(--accent);
    box-shadow: 0 0 0 6px rgba(127, 209, 255, 0.25);
    cursor: pointer;
    margin-top: -7px;
  }

  input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #ffffff;
    border: 2px solid var(--accent);
    box-shadow: 0 0 0 6px rgba(127, 209, 255, 0.25);
    cursor: pointer;
  }

  input[type="range"]::-moz-range-track {
    height: 4px;
    border-radius: 999px;
    background: linear-gradient(90deg, var(--accent-soft), rgba(255,255,255,0.04));
  }

  input[type="checkbox"] {
    width: 18px;
    height: 18px;
    margin-right: 0.5rem;
    cursor: pointer;
    accent-color: var(--accent);
  }

  .row label {
    display: flex;
    align-items: center;
    cursor: pointer;
    font-size: 0.9rem;
    color: var(--text-main);
  }

  small {
    color: var(--text-muted);
    font-size: 0.8rem;
    line-height: 1.4;
    display: block;
    margin-top: 0.75rem;
    opacity: 0.85;
  }

  .pill {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid var(--accent-soft);
    border-radius: 999px;
    padding: 0.35rem 0.75rem;
    margin-right: 6px;
    font-size: 0.75rem;
    color: var(--text-muted);
  }

  @media (max-width: 480px) {
    body {
      padding: 1rem;
    }
    .app {
      padding: 1.25rem 1.1rem 1.4rem;
      border-radius: 20px;
    }
    header h1 {
      font-size: 1.35rem;
    }
    .ctrl {
      grid-template-columns: 100px 1fr 50px;
      gap: 8px;
    }
  }
</style>
</head>
<body>

<div class="app">
  <header>
    <h1>Nature Sounds Synth</h1>
    <p>Procedural ambient nature sounds</p>
  </header>

  <div class="card">
  <div class="row">
    <button id="btnPlay">▶ Play</button>
    <button id="btnStop" disabled>Stop</button>

    <span class="pill">All sounds are synthesized (no samples)</span>
  </div>

  <div class="row">
    <label>Category</label>
    <select id="selCategory"></select>

    <label>Preset</label>
    <select id="selPreset"></select>

    <button id="btnRandom">Randomize (gentle)</button>
  </div>

  <div class="grid">
    <div class="card">
      <div class="ctrl"><label>Master</label><input id="rngMaster" type="range" min="0" max="1" step="0.001" value="0.35"><span id="vMaster"></span></div>
      <div class="ctrl"><label>Intensity</label><input id="rngIntensity" type="range" min="0" max="1" step="0.001" value="0.5"><span id="vIntensity"></span></div>
      <div class="ctrl"><label>Density</label><input id="rngDensity" type="range" min="0" max="1" step="0.001" value="0.5"><span id="vDensity"></span></div>
      <div class="ctrl"><label>Brightness</label><input id="rngBright" type="range" min="0" max="1" step="0.001" value="0.5"><span id="vBright"></span></div>
      <div class="ctrl"><label>Variation</label><input id="rngVar" type="range" min="0" max="1" step="0.001" value="0.5"><span id="vVar"></span></div>
      <div class="ctrl"><label>Distance</label><input id="rngDist" type="range" min="0" max="1" step="0.001" value="0.25"><span id="vDist"></span></div>
    </div>

    <div class="card">
      <div class="ctrl"><label>Reverb Mix</label><input id="rngRev" type="range" min="0" max="1" step="0.001" value="0.12"><span id="vRev"></span></div>
      <div class="ctrl"><label>Crossfade</label><input id="rngXfade" type="range" min="0" max="2" step="0.01" value="0.35"><span id="vXfade"></span></div>

      <div class="row">
        <label><input id="chkRain" type="checkbox" checked> Rain</label>
        <label><input id="chkWind" type="checkbox" checked> Wind</label>
        <label><input id="chkOcean" type="checkbox"> Ocean</label>
        <label><input id="chkStream" type="checkbox"> Stream</label>
        <label><input id="chkFire" type="checkbox"> Fire</label>
        <label><input id="chkCrickets" type="checkbox"> Crickets</label>
      </div>

      <small>
        Tip: Use presets first; then tweak macro knobs. Intensity affects loudness/energy, Density affects event rate (drops/crackles/chirps),
        Brightness tilts EQ, Variation makes motion more “alive”, Distance adds damping + reverb.
      </small>
    </div>
  </div>
  </div>
</div>

<script>
/* ---------------------------
   Utilities
----------------------------*/
const clamp01 = (x)=>Math.max(0,Math.min(1,x));
const lerp = (a,b,t)=>a+(b-a)*t;
const expRand = (mean)=> -Math.log(1-Math.random())*mean; // exponential
const now = (ctx)=>ctx.currentTime;
function setParam(param, value, t=0.02, ctx=null){
  const tt = ctx ? ctx.currentTime : 0;
  param.cancelScheduledValues(tt);
  param.setTargetAtTime(value, tt, t);
}

/* ---------------------------
   Audio context + worklet noise
----------------------------*/
let ctx=null;
let masterGain=null, masterLP=null, comp=null;
let wetGain=null, dryGain=null, convolver=null;
let useWorklet=false;

async function ensureAudio(){
  if (ctx) return;

  ctx = new (window.AudioContext || window.webkitAudioContext)();

  // Try to use AudioWorklet, fallback to ScriptProcessorNode if it fails
  useWorklet = false;
  try {
    // Use data URL instead of blob URL to avoid CORS issues
    const workletCode = `
class NoiseGen extends AudioWorkletProcessor {
  static get parameterDescriptors(){
    return [{name:'type', defaultValue:0}, {name:'amp', defaultValue:0.2}];
  }
  constructor(){
    super();
    this.b0=0; this.b1=0; this.b2=0; this.b3=0; this.b4=0; this.b5=0; this.b6=0;
    this.brown=0;
  }
  process(inputs, outputs, params){
    const out = outputs[0][0];
    const type = params.type;
    const amp  = params.amp;
    for (let i=0;i<out.length;i++){
      const t = type.length>1 ? type[i] : type[0];
      const a = amp.length>1 ? amp[i] : amp[0];
      let white = Math.random()*2-1;
      let y=white;
      if (t<0.5){
        y = white;
      } else if (t<1.5){
        this.b0 = 0.99886*this.b0 + white*0.0555179;
        this.b1 = 0.99332*this.b1 + white*0.0750759;
        this.b2 = 0.96900*this.b2 + white*0.1538520;
        this.b3 = 0.86650*this.b3 + white*0.3104856;
        this.b4 = 0.55000*this.b4 + white*0.5329522;
        this.b5 = -0.7616*this.b5 - white*0.0168980;
        y = this.b0 + this.b1 + this.b2 + this.b3 + this.b4 + this.b5 + this.b6 + white*0.5362;
        this.b6 = white*0.115926;
        y *= 0.11;
      } else {
        this.brown = (this.brown + 0.02*white) * 0.999;
        y = this.brown * 3.5;
      }
      out[i] = y * a;
    }
    return true;
  }
}
registerProcessor('noise-gen', NoiseGen);
`;
    // Use data URL with proper encoding
    const dataUrl = 'data:text/javascript;base64,' + btoa(workletCode);
    await ctx.audioWorklet.addModule(dataUrl);
    useWorklet = true;
    console.log("AudioWorklet loaded successfully");
  } catch (err) {
    console.warn("AudioWorklet failed, using fallback:", err);
    useWorklet = false;
  }

  // Master chain
  masterGain = ctx.createGain();
  dryGain = ctx.createGain();
  wetGain = ctx.createGain();
  comp = ctx.createDynamicsCompressor();
  masterLP = ctx.createBiquadFilter();
  masterLP.type = "lowpass";
  masterLP.frequency.value = 20000;

  convolver = ctx.createConvolver();
  convolver.buffer = makeImpulseResponse(ctx, 1.4, 0.35); // default

  dryGain.connect(comp);
  wetGain.connect(convolver);
  convolver.connect(comp);
  comp.connect(masterLP);
  masterLP.connect(masterGain);
  masterGain.connect(ctx.destination);

  setParam(masterGain.gain, 0.35, 0.02, ctx);
  setParam(dryGain.gain, 1.0, 0.02, ctx);
  setParam(wetGain.gain, 0.12, 0.02, ctx);
}

function makeImpulseResponse(ctx, seconds=1.2, damp=0.4){
  const rate = ctx.sampleRate;
  const len = Math.max(1, Math.floor(seconds*rate));
  const buf = ctx.createBuffer(2, len, rate);
  for (let c=0;c<2;c++){
    const data = buf.getChannelData(c);
    let lp = 0;
    for (let i=0;i<len;i++){
      const t = i/len;
      const decay = Math.pow(1 - t, 2.5);
      const n = (Math.random()*2-1) * decay;
      // simple damping (one-pole lowpass inside IR)
      lp = lp + (n - lp) * (1 - damp);
      data[i] = lp;
    }
  }
  return buf;
}

// Fallback noise generator using ScriptProcessorNode
class FallbackNoiseGen {
  constructor(type=0, amp=0.2){
    this.type = type;
    this.amp = amp;
    this.b0=0; this.b1=0; this.b2=0; this.b3=0; this.b4=0; this.b5=0; this.b6=0;
    this.brown=0;
    
    const bufferSize = 4096;
    this.node = ctx.createScriptProcessor(bufferSize, 0, 1);
    const self = this;
    this.node.onaudioprocess = function(e){
      const output = e.outputBuffer.getChannelData(0);
      for(let i=0; i<output.length; i++){
        let white = Math.random()*2-1;
        let y = white;
        if(self.type < 0.5){
          y = white;
        } else if(self.type < 1.5){
          self.b0 = 0.99886*self.b0 + white*0.0555179;
          self.b1 = 0.99332*self.b1 + white*0.0750759;
          self.b2 = 0.96900*self.b2 + white*0.1538520;
          self.b3 = 0.86650*self.b3 + white*0.3104856;
          self.b4 = 0.55000*self.b4 + white*0.5329522;
          self.b5 = -0.7616*self.b5 - white*0.0168980;
          y = self.b0 + self.b1 + self.b2 + self.b3 + self.b4 + self.b5 + self.b6 + white*0.5362;
          self.b6 = white*0.115926;
          y *= 0.11;
        } else {
          self.brown = (self.brown + 0.02*white) * 0.999;
          y = self.brown * 3.5;
        }
        output[i] = y * self.amp;
      }
    };
  }
  connect(dest){ this.node.connect(dest); }
  disconnect(){ this.node.disconnect(); }
  get parameters(){
    return {
      get: (name) => ({
        value: name === 'type' ? this.type : this.amp,
        setValueAtTime: (val) => {
          if(name === 'type') this.type = val;
          else this.amp = val;
        }
      })
    };
  }
}

function createNoise(type=0, amp=0.2){
  if(useWorklet){
    try {
      const n = new AudioWorkletNode(ctx, "noise-gen", {numberOfOutputs:1, outputChannelCount:[1]});
      n.parameters.get("type").value = type;
      n.parameters.get("amp").value = amp;
      return n;
    } catch (err) {
      console.warn("AudioWorkletNode creation failed, using fallback:", err);
      return new FallbackNoiseGen(type, amp);
    }
  } else {
    return new FallbackNoiseGen(type, amp);
  }
}

/* ---------------------------
   Modules
----------------------------*/
class Rain {
  constructor(){
    this.on=false;
    this.base=null;
    this.baseLP=null;
    this.baseGain=null;
    this.dropBP=null;
    this.dropGain=null;
    this.timer=null;
  }
  start(dest){
    if (this.on) return;
    this.on=true;

    this.base = createNoise(1, 0.18); // pink-ish
    this.baseLP = ctx.createBiquadFilter(); this.baseLP.type="lowpass"; this.baseLP.frequency.value=8500;
    this.baseGain = ctx.createGain(); this.baseGain.gain.value=0.15;

    this.dropBP = ctx.createBiquadFilter(); this.dropBP.type="bandpass"; this.dropBP.frequency.value=4500; this.dropBP.Q.value=2.2;
    this.dropGain = ctx.createGain(); this.dropGain.gain.value=0.0;

    this.base.connect(this.baseLP); this.baseLP.connect(this.baseGain); this.baseGain.connect(dest);
    this.base.connect(this.dropBP); this.dropBP.connect(this.dropGain); this.dropGain.connect(dest);

    this.timer = setInterval(()=>this._tick(), 40);
  }
  stop(){
    this.on=false;
    if (this.timer) clearInterval(this.timer), this.timer=null;
    [this.base,this.baseLP,this.baseGain,this.dropBP,this.dropGain].forEach(n=>{try{n && n.disconnect();}catch{}});
    this.base=this.baseLP=this.baseGain=this.dropBP=this.dropGain=null;
  }
  set(p){
    if (!this.on) return;
    const {intensity,density,brightness,variation,distance} = p;
    const base = 0.05 + 0.30*intensity;
    setParam(this.baseGain.gain, base*(1-0.35*distance), 0.05, ctx);
    setParam(this.baseLP.frequency, lerp(4500, 12000, brightness)*(1-0.45*distance), 0.08, ctx);
    setParam(this.dropBP.frequency, lerp(2500, 7500, brightness), 0.08, ctx);
    this._rate = lerp(2, 26, density) * lerp(0.7, 1.3, variation);
    this._dropLevel = lerp(0.02, 0.30, intensity);
  }
  _tick(){
    if (!this.on) return;
    if (Math.random() < (this._rate||8) * 0.04){
      // raindrop: very short gain envelope on filtered noise
      const t = now(ctx);
      const g = this.dropGain.gain;
      const peak = (this._dropLevel||0.12) * (0.6+0.8*Math.random());
      g.cancelScheduledValues(t);
      g.setValueAtTime(0.0, t);
      g.linearRampToValueAtTime(peak, t+0.004);
      g.exponentialRampToValueAtTime(0.0001, t+0.030 + 0.040*Math.random());
    }
  }
}

class Wind {
  constructor(){
    this.on=false; this.n=null; this.lp=null; this.g=null;
    this.gust=null;
  }
  start(dest){
    if (this.on) return;
    this.on=true;
    this.n = createNoise(2, 0.35); // brown-ish
    this.lp = ctx.createBiquadFilter(); this.lp.type="lowpass"; this.lp.frequency.value=900;
    this.g = ctx.createGain(); this.g.gain.value=0.0;
    this.n.connect(this.lp); this.lp.connect(this.g); this.g.connect(dest);
    this._scheduleGust();
  }
  stop(){
    this.on=false;
    if (this.gust) clearTimeout(this.gust), this.gust=null;
    [this.n,this.lp,this.g].forEach(n=>{try{n && n.disconnect();}catch{}});
    this.n=this.lp=this.g=null;
  }
  set(p){
    if (!this.on) return;
    const {intensity,brightness,variation,distance} = p;
    setParam(this.g.gain, (0.02 + 0.35*intensity)*(1-0.25*distance), 0.08, ctx);
    setParam(this.lp.frequency, lerp(250, 1800, brightness)*(1-0.4*distance), 0.10, ctx);
    this._var = variation;
  }
  _scheduleGust(){
    if (!this.on) return;
    const t = now(ctx);
    const v = this._var ?? 0.5;
    const base = this.g.gain.value;
    const peak = base * lerp(1.05, 1.9, v) * (0.7+0.8*Math.random());
    const dur = lerp(0.6, 3.5, v) * (0.7+0.8*Math.random());

    this.g.gain.cancelScheduledValues(t);
    this.g.gain.setValueAtTime(base, t);
    this.g.gain.linearRampToValueAtTime(peak, t + 0.10);
    this.g.gain.linearRampToValueAtTime(base, t + dur);

    this.gust = setTimeout(()=>this._scheduleGust(), 400 + expRand(1400 + 2000*(1-v)));
  }
}

class Ocean {
  constructor(){
    this.on=false; this.body=null; this.bodyLP=null; this.bodyG=null;
    this.surf=null; this.surfBP=null; this.surfG=null;
    this.timer=null;
  }
  start(dest){
    if (this.on) return;
    this.on=true;

    this.body = createNoise(2, 0.35);
    this.bodyLP = ctx.createBiquadFilter(); this.bodyLP.type="lowpass"; this.bodyLP.frequency.value=220;
    this.bodyG = ctx.createGain(); this.bodyG.gain.value=0.0;

    this.surf = createNoise(1, 0.22);
    this.surfBP = ctx.createBiquadFilter(); this.surfBP.type="bandpass"; this.surfBP.frequency.value=850; this.surfBP.Q.value=0.8;
    this.surfG = ctx.createGain(); this.surfG.gain.value=0.0;

    this.body.connect(this.bodyLP); this.bodyLP.connect(this.bodyG); this.bodyG.connect(dest);
    this.surf.connect(this.surfBP); this.surfBP.connect(this.surfG); this.surfG.connect(dest);

    this.timer = setInterval(()=>this._swell(), 180);
  }
  stop(){
    this.on=false;
    if (this.timer) clearInterval(this.timer), this.timer=null;
    [this.body,this.bodyLP,this.bodyG,this.surf,this.surfBP,this.surfG].forEach(n=>{try{n && n.disconnect();}catch{}});
    this.body=this.bodyLP=this.bodyG=this.surf=this.surfBP=this.surfG=null;
  }
  set(p){
    if (!this.on) return;
    const {intensity,density,brightness,variation,distance} = p;
    this._int = intensity; this._den=density; this._br=brightness; this._var=variation; this._dist=distance;
    setParam(this.bodyLP.frequency, lerp(120, 420, brightness), 0.15, ctx);
    setParam(this.surfBP.frequency, lerp(450, 1600, brightness), 0.15, ctx);
    this._swellRate = lerp(0.06, 0.16, density) * lerp(0.8, 1.2, variation); // Hz-ish
  }
  _swell(){
    if (!this.on) return;
    const t = now(ctx);
    const r = this._swellRate || 0.10;
    const phase = (t * r) % 1;
    const swell = 0.35 + 0.65*(0.5 - 0.5*Math.cos(phase*2*Math.PI)); // 0.35..1
    const dist = this._dist ?? 0.2;

    const body = (0.04 + 0.35*(this._int??0.5)) * swell * (1-0.25*dist);
    const surf = (0.02 + 0.25*(this._int??0.5)) * swell * (1-0.45*dist);

    setParam(this.bodyG.gain, body, 0.18, ctx);
    setParam(this.surfG.gain, surf, 0.12, ctx);
  }
}

class Fire {
  constructor(){
    this.on=false;
    this.base=null; this.hp=null; this.g=null;
    this.crackleBP=null; this.crackleG=null;
    this.timer=null;
  }
  start(dest){
    if (this.on) return;
    this.on=true;

    this.base = createNoise(1, 0.25);
    this.hp = ctx.createBiquadFilter(); this.hp.type="highpass"; this.hp.frequency.value=90;
    this.g = ctx.createGain(); this.g.gain.value=0.0;

    this.crackleBP = ctx.createBiquadFilter(); this.crackleBP.type="bandpass"; this.crackleBP.frequency.value=3000; this.crackleBP.Q.value=3.0;
    this.crackleG = ctx.createGain(); this.crackleG.gain.value=0.0;

    this.base.connect(this.hp); this.hp.connect(this.g); this.g.connect(dest);
    this.base.connect(this.crackleBP); this.crackleBP.connect(this.crackleG); this.crackleG.connect(dest);

    this.timer=setInterval(()=>this._tick(), 35);
  }
  stop(){
    this.on=false;
    if (this.timer) clearInterval(this.timer), this.timer=null;
    [this.base,this.hp,this.g,this.crackleBP,this.crackleG].forEach(n=>{try{n && n.disconnect();}catch{}});
    this.base=this.hp=this.g=this.crackleBP=this.crackleG=null;
  }
  set(p){
    if (!this.on) return;
    const {intensity,density,brightness,variation,distance} = p;
    setParam(this.g.gain, (0.01+0.22*intensity)*(1-0.25*distance), 0.10, ctx);
    setParam(this.crackleBP.frequency, lerp(1800, 5200, brightness), 0.10, ctx);
    this._rate = lerp(1, 30, density) * lerp(0.8, 1.3, variation);
    this._lvl = lerp(0.02, 0.35, intensity);
  }
  _tick(){
    if (!this.on) return;
    if (Math.random() < (this._rate||10) * 0.035){
      const t=now(ctx);
      const g=this.crackleG.gain;
      const peak = (this._lvl||0.12) * (0.3 + 1.2*Math.random());
      g.cancelScheduledValues(t);
      g.setValueAtTime(0.0001, t);
      g.exponentialRampToValueAtTime(peak, t+0.003);
      g.exponentialRampToValueAtTime(0.0001, t+0.020 + 0.060*Math.random());
    }
  }
}

class Crickets {
  constructor(){
    this.on=false;
    this.crickets=[]; // Multiple cricket instances
    this.ambient=null; this.ambientBP=null; this.ambientG=null;
    this.timers=[];
  }
  start(dest){
    if (this.on) return;
    this.on=true;
    
    // Create 4-5 individual crickets for realism
    const numCrickets = 5;
    for(let i=0; i<numCrickets; i++){
      const cricket = {
        n: createNoise(0, 0.15),
        bp: ctx.createBiquadFilter(),
        g: ctx.createGain(),
        panner: ctx.createStereoPanner(),
        nextChirp: 0,
        phase: Math.random() * 2 * Math.PI, // Random starting phase
        baseFreq: lerp(3200, 4800, Math.random()), // California cricket range
        rate: 0
      };
      cricket.bp.type = "bandpass";
      cricket.bp.frequency.value = cricket.baseFreq;
      cricket.bp.Q.value = 6 + Math.random() * 4; // 6-10 Q for sharper chirps
      cricket.g.gain.value = 0.0;
      cricket.panner.pan.value = (Math.random() * 2 - 1) * 0.6; // Spread across stereo
      
      cricket.n.connect(cricket.bp);
      cricket.bp.connect(cricket.g);
      cricket.g.connect(cricket.panner);
      cricket.panner.connect(dest);
      
      this.crickets.push(cricket);
    }
    
    // Subtle ambient cricket background
    this.ambient = createNoise(1, 0.08); // Pink noise for smoother background
    this.ambientBP = ctx.createBiquadFilter();
    this.ambientBP.type = "bandpass";
    this.ambientBP.frequency.value = 3800;
    this.ambientBP.Q.value = 2.0; // Wider Q for background
    this.ambientG = ctx.createGain();
    this.ambientG.gain.value = 0.0;
    this.ambient.connect(this.ambientBP);
    this.ambientBP.connect(this.ambientG);
    this.ambientG.connect(dest);
    
    // Schedule chirps for each cricket independently
    this.crickets.forEach((cricket, i) => {
      const timer = setInterval(() => this._chirp(cricket), 30);
      this.timers.push(timer);
      // Stagger initial chirps
      setTimeout(() => this._chirp(cricket), i * 200);
    });
  }
  stop(){
    this.on=false;
    this.timers.forEach(t => clearInterval(t));
    this.timers = [];
    this.crickets.forEach(c => {
      [c.n, c.bp, c.g, c.panner].forEach(n => {try{n && n.disconnect();}catch{}});
    });
    [this.ambient, this.ambientBP, this.ambientG].forEach(n => {try{n && n.disconnect();}catch{}});
    this.crickets = [];
    this.ambient = this.ambientBP = this.ambientG = null;
  }
  set(p){
    if (!this.on) return;
    const {intensity,density,brightness,variation,distance} = p;
    
    // Update each cricket
    this.crickets.forEach((cricket, i) => {
      const freq = lerp(2800, 5500, brightness) * (0.85 + 0.3*Math.random());
      cricket.baseFreq = freq;
      setParam(cricket.bp.frequency, freq * (1-0.2*distance), 0.2, ctx);
      
      // Individual cricket rates (some faster, some slower)
      const baseRate = lerp(0.8, 3.5, density);
      cricket.rate = baseRate * (0.7 + 0.6*Math.random()) * lerp(0.9, 1.3, variation);
    });
    
    this._lvl = (0.015 + 0.18*intensity) * (1-0.4*distance);
    this._ambientLvl = (0.003 + 0.012*intensity) * (1-0.5*distance);
    
    // Update ambient background
    setParam(this.ambientBP.frequency, lerp(3200, 4500, brightness), 0.3, ctx);
    setParam(this.ambientG.gain, this._ambientLvl || 0.005, 0.2, ctx);
  }
  _chirp(cricket){
    if (!this.on || !cricket) return;
    
    const t = now(ctx);
    const rate = cricket.rate || 1.5;
    
    // Chirp probability based on rate
    if (Math.random() < rate * 0.04){
      // California crickets chirp in bursts of 2-4 pulses
      const numPulses = 2 + Math.floor(Math.random() * 3); // 2-4 pulses
      const pulseInterval = 0.015 + Math.random() * 0.010; // 15-25ms between pulses
      const chirpDuration = numPulses * pulseInterval + 0.010;
      
      const peak = (this._lvl || 0.05) * (0.7 + 0.6*Math.random());
      
      // Create a more realistic chirp envelope with multiple pulses
      const g = cricket.g.gain;
      g.cancelScheduledValues(t);
      g.setValueAtTime(0.0001, t);
      
      // Build up to first pulse
      g.linearRampToValueAtTime(peak * 0.3, t + 0.001);
      
      // Multiple pulses
      for(let p = 0; p < numPulses; p++){
        const pulseTime = t + 0.001 + p * pulseInterval;
        const pulsePeak = peak * (0.8 + 0.4*Math.random());
        g.linearRampToValueAtTime(pulsePeak, pulseTime);
        g.linearRampToValueAtTime(pulsePeak * 0.4, pulseTime + 0.003);
      }
      
      // Fade out
      g.exponentialRampToValueAtTime(0.0001, t + chirpDuration);
      
      // Slight frequency modulation during chirp (more realistic)
      const freqMod = cricket.baseFreq * (0.95 + 0.1*Math.random());
      cricket.bp.frequency.setValueAtTime(freqMod, t);
      cricket.bp.frequency.exponentialRampToValueAtTime(cricket.baseFreq, t + chirpDuration);
    }
  }
}

class Stream {
  constructor(){
    this.on=false;
    this.n=null; this.bp=null; this.g=null;
    this.bub=null; this.bubG=null;
    this.timer=null; this.move=null;
  }
  start(dest){
    if (this.on) return;
    this.on=true;

    this.n = createNoise(1, 0.25);
    this.bp = ctx.createBiquadFilter(); this.bp.type="bandpass"; this.bp.frequency.value=650; this.bp.Q.value=0.9;
    this.g  = ctx.createGain(); this.g.gain.value=0.0;

    this.n.connect(this.bp); this.bp.connect(this.g); this.g.connect(dest);

    // bubbles: use filtered noise bursts (resonant-ish)
    this.bub = createNoise(0, 0.18);
    this.bubBP = ctx.createBiquadFilter(); this.bubBP.type="bandpass"; this.bubBP.frequency.value=900; this.bubBP.Q.value=6;
    this.bubG = ctx.createGain(); this.bubG.gain.value=0.0;
    this.bub.connect(this.bubBP); this.bubBP.connect(this.bubG); this.bubG.connect(dest);

    this.timer=setInterval(()=>this._bubble(), 90);
    this.move=setInterval(()=>this._drift(), 220);
  }
  stop(){
    this.on=false;
    if (this.timer) clearInterval(this.timer), this.timer=null;
    if (this.move) clearInterval(this.move), this.move=null;
    [this.n,this.bp,this.g,this.bub,this.bubBP,this.bubG].forEach(n=>{try{n && n.disconnect();}catch{}});
    this.n=this.bp=this.g=this.bub=this.bubBP=this.bubG=null;
  }
  set(p){
    if (!this.on) return;
    const {intensity,density,brightness,variation,distance} = p;
    setParam(this.g.gain, (0.02+0.28*intensity)*(1-0.35*distance), 0.12, ctx);
    this._den=density; this._var=variation; this._int=intensity; this._br=brightness; this._dist=distance;
    setParam(this.bp.Q, lerp(0.6, 1.2, brightness), 0.15, ctx);
  }
  _drift(){
    if (!this.on) return;
    const br = this._br ?? 0.5;
    const v  = this._var ?? 0.5;
    const center = lerp(350, 1200, br) * (0.8 + 0.4*Math.random());
    const wobble = lerp(10, 120, v);
    setParam(this.bp.frequency, center + (Math.random()*2-1)*wobble, 0.20, ctx);
  }
  _bubble(){
    if (!this.on) return;
    const density = this._den ?? 0.4;
    const v = this._var ?? 0.5;
    const chance = lerp(0.05, 0.35, density) * lerp(0.8, 1.3, v);
    if (Math.random() < chance){
      const t=now(ctx);
      const g=this.bubG.gain;
      const peak = (0.01 + 0.12*(this._int??0.5)) * (0.4+0.8*Math.random()) * (1-0.4*(this._dist??0.2));
      const freq = lerp(500, 1400, this._br??0.5) * (0.7+0.7*Math.random());
      this.bubBP.frequency.setTargetAtTime(freq, t, 0.01);
      g.cancelScheduledValues(t);
      g.setValueAtTime(0.0001, t);
      g.exponentialRampToValueAtTime(peak, t+0.005);
      g.exponentialRampToValueAtTime(0.0001, t+0.08+0.12*Math.random());
    }
  }
}

/* ---------------------------
   Presets (top 5-ish per category)
----------------------------*/
const PRESETS = {
  "Water": [
    {name:"Gentle Rain on Leaves", modules:{rain:true,wind:true,ocean:false,stream:false,fire:false,crickets:false},
      p:{master:0.33,intensity:0.40,density:0.55,brightness:0.55,variation:0.35,distance:0.28,reverb:0.14}},
    {name:"Steady Rain (Soft)", modules:{rain:true,wind:false,ocean:false,stream:false,fire:false,crickets:false},
      p:{master:0.33,intensity:0.50,density:0.70,brightness:0.48,variation:0.25,distance:0.18,reverb:0.10}},
    {name:"Ocean Night (Distant Surf)", modules:{rain:false,wind:true,ocean:true,stream:false,fire:false,crickets:false},
      p:{master:0.33,intensity:0.45,density:0.40,brightness:0.40,variation:0.40,distance:0.55,reverb:0.18}},
    {name:"Creek by the Trail", modules:{rain:false,wind:true,ocean:false,stream:true,fire:false,crickets:false},
      p:{master:0.33,intensity:0.55,density:0.45,brightness:0.55,variation:0.55,distance:0.25,reverb:0.12}},
    {name:"Rain + Stream Blend", modules:{rain:true,wind:true,ocean:false,stream:true,fire:false,crickets:false},
      p:{master:0.34,intensity:0.45,density:0.55,brightness:0.55,variation:0.50,distance:0.30,reverb:0.14}},
  ],
  "Wind": [
    {name:"Pine Breeze", modules:{rain:false,wind:true,ocean:false,stream:false,fire:false,crickets:false},
      p:{master:0.32,intensity:0.35,density:0.30,brightness:0.40,variation:0.55,distance:0.35,reverb:0.12}},
    {name:"Coastal Wind", modules:{rain:false,wind:true,ocean:true,stream:false,fire:false,crickets:false},
      p:{master:0.33,intensity:0.40,density:0.40,brightness:0.45,variation:0.50,distance:0.45,reverb:0.16}},
    {name:"Autumn Gusts (Soft)", modules:{rain:false,wind:true,ocean:false,stream:false,fire:false,crickets:false},
      p:{master:0.33,intensity:0.50,density:0.55,brightness:0.35,variation:0.75,distance:0.40,reverb:0.14}},
    {name:"Mountain Air (Distant)", modules:{rain:false,wind:true,ocean:false,stream:false,fire:false,crickets:false},
      p:{master:0.31,intensity:0.35,density:0.25,brightness:0.30,variation:0.35,distance:0.70,reverb:0.22}},
    {name:"Wind + Light Rain", modules:{rain:true,wind:true,ocean:false,stream:false,fire:false,crickets:false},
      p:{master:0.33,intensity:0.35,density:0.45,brightness:0.50,variation:0.55,distance:0.35,reverb:0.14}},
  ],
  "Night": [
    {name:"Summer Crickets (Gentle)", modules:{rain:false,wind:false,ocean:false,stream:false,fire:false,crickets:true},
      p:{master:0.30,intensity:0.35,density:0.40,brightness:0.60,variation:0.55,distance:0.35,reverb:0.12}},
    {name:"Crickets + Breeze", modules:{rain:false,wind:true,ocean:false,stream:false,fire:false,crickets:true},
      p:{master:0.32,intensity:0.35,density:0.45,brightness:0.55,variation:0.55,distance:0.40,reverb:0.14}},
    {name:"Night Creek", modules:{rain:false,wind:true,ocean:false,stream:true,fire:false,crickets:true},
      p:{master:0.33,intensity:0.40,density:0.40,brightness:0.50,variation:0.55,distance:0.45,reverb:0.16}},
    {name:"Distant Surf + Insects", modules:{rain:false,wind:true,ocean:true,stream:false,fire:false,crickets:true},
      p:{master:0.33,intensity:0.38,density:0.35,brightness:0.45,variation:0.45,distance:0.55,reverb:0.18}},
    {name:"Rainy Night (Crickets tucked)", modules:{rain:true,wind:true,ocean:false,stream:false,fire:false,crickets:true},
      p:{master:0.33,intensity:0.42,density:0.55,brightness:0.50,variation:0.45,distance:0.35,reverb:0.15}},
  ],
  "Fire": [
    {name:"Campfire (Close, Soft)", modules:{rain:false,wind:false,ocean:false,stream:false,fire:true,crickets:false},
      p:{master:0.30,intensity:0.35,density:0.45,brightness:0.45,variation:0.55,distance:0.20,reverb:0.12}},
    {name:"Campfire + Night Bugs", modules:{rain:false,wind:false,ocean:false,stream:false,fire:true,crickets:true},
      p:{master:0.31,intensity:0.35,density:0.45,brightness:0.55,variation:0.55,distance:0.30,reverb:0.14}},
    {name:"Fire in the Distance", modules:{rain:false,wind:true,ocean:false,stream:false,fire:true,crickets:false},
      p:{master:0.30,intensity:0.32,density:0.35,brightness:0.40,variation:0.45,distance:0.70,reverb:0.24}},
    {name:"Warm Cabin Vibe", modules:{rain:true,wind:false,ocean:false,stream:false,fire:true,crickets:false},
      p:{master:0.32,intensity:0.35,density:0.50,brightness:0.35,variation:0.35,distance:0.35,reverb:0.18}},
    {name:"Fire + Ocean Night", modules:{rain:false,wind:true,ocean:true,stream:false,fire:true,crickets:false},
      p:{master:0.32,intensity:0.35,density:0.35,brightness:0.40,variation:0.45,distance:0.55,reverb:0.20}},
  ]
};

const DEFAULT_CATEGORY = "Water";

/* ---------------------------
   App state + wiring
----------------------------*/
const ui = {
  btnPlay: q("#btnPlay"), btnStop: q("#btnStop"), btnRandom: q("#btnRandom"),
  selCategory: q("#selCategory"), selPreset: q("#selPreset"),
  rngMaster:q("#rngMaster"), rngIntensity:q("#rngIntensity"), rngDensity:q("#rngDensity"),
  rngBright:q("#rngBright"), rngVar:q("#rngVar"), rngDist:q("#rngDist"),
  rngRev:q("#rngRev"), rngXfade:q("#rngXfade"),
  vMaster:q("#vMaster"), vIntensity:q("#vIntensity"), vDensity:q("#vDensity"),
  vBright:q("#vBright"), vVar:q("#vVar"), vDist:q("#vDist"),
  vRev:q("#vRev"), vXfade:q("#vXfade"),
  chkRain:q("#chkRain"), chkWind:q("#chkWind"), chkOcean:q("#chkOcean"),
  chkStream:q("#chkStream"), chkFire:q("#chkFire"), chkCrickets:q("#chkCrickets"),
};
function q(s){return document.querySelector(s);}

let modules = {};
let running=false;

function getMacros(){
  return {
    master: +ui.rngMaster.value,
    intensity: +ui.rngIntensity.value,
    density: +ui.rngDensity.value,
    brightness: +ui.rngBright.value,
    variation: +ui.rngVar.value,
    distance: +ui.rngDist.value,
    reverb: +ui.rngRev.value,
    xfade: +ui.rngXfade.value
  };
}

function updateLabels(){
  const m = getMacros();
  ui.vMaster.textContent = m.master.toFixed(2);
  ui.vIntensity.textContent = m.intensity.toFixed(2);
  ui.vDensity.textContent = m.density.toFixed(2);
  ui.vBright.textContent = m.brightness.toFixed(2);
  ui.vVar.textContent = m.variation.toFixed(2);
  ui.vDist.textContent = m.distance.toFixed(2);
  ui.vRev.textContent = m.reverb.toFixed(2);
  ui.vXfade.textContent = m.xfade.toFixed(2);
}

function selectedModules(){
  return {
    rain: ui.chkRain.checked,
    wind: ui.chkWind.checked,
    ocean: ui.chkOcean.checked,
    stream: ui.chkStream.checked,
    fire: ui.chkFire.checked,
    crickets: ui.chkCrickets.checked
  };
}

function applyMacros(){
  if (!ctx) return;
  const m = getMacros();

  // master volume + distance rolloff + reverb
  setParam(masterGain.gain, m.master, 0.08, ctx);
  setParam(wetGain.gain, m.reverb, 0.08, ctx);

  // distance = more damping on master
  const lp = lerp(16000, 2600, m.distance);
  setParam(masterLP.frequency, lp, 0.10, ctx);

  // push macros into modules
  Object.values(modules).forEach(mod=>{
    if (mod && mod.set && mod.on) {
      mod.set(m);
    }
  });
}

function syncModuleToggles(withXfade=true){
  if (!ctx) return;
  const want = selectedModules();
  const tFade = getMacros().xfade;

  const dest = dryGain; // dry -> master; wet handled by wetGain + convolver
  // Simple: route all modules into dry+wet via splitter gains
  // We'll feed modules into a bus that also goes to wetGain.
  // (Simpler: modules connect to BOTH dryGain and wetGain through a small "send" node.)
  // We'll create a shared bus once:
  if (!modules._bus){
    modules._bus = ctx.createGain();
    modules._bus.gain.value = 1.0;
    modules._bus.connect(dryGain);
    modules._bus.connect(wetGain);
  }

  const bus = modules._bus;

  const ensure = (key, ctor)=>{
    if (want[key] && !modules[key]){
      try {
        modules[key] = new ctor();
        modules[key].start(bus);
        // Set parameters immediately after starting
        if (modules[key].on) {
          modules[key].set(getMacros());
        }
      } catch (err) {
        console.error(`Failed to start ${key} module:`, err);
      }
    } else if (!want[key] && modules[key]){
      // quick fade-out by lowering master rather than per-module (simple & smooth enough)
      const stopLater = modules[key];
      setTimeout(()=>{ 
        try { stopLater.stop(); } catch(e) { console.error(e); }
      }, Math.max(0, (tFade*1000)|0));
      delete modules[key];
    }
  };

  ensure("rain", Rain);
  ensure("wind", Wind);
  ensure("ocean", Ocean);
  ensure("stream", Stream);
  ensure("fire", Fire);
  ensure("crickets", Crickets);

  applyMacros();
}

function setFromPreset(preset){
  const tFade = getMacros().xfade;
  const m = preset.p;
  // sliders
  ui.rngMaster.value = m.master;
  ui.rngIntensity.value = m.intensity;
  ui.rngDensity.value = m.density;
  ui.rngBright.value = m.brightness;
  ui.rngVar.value = m.variation;
  ui.rngDist.value = m.distance;
  ui.rngRev.value = m.reverb;

  // module toggles
  ui.chkRain.checked = preset.modules.rain;
  ui.chkWind.checked = preset.modules.wind;
  ui.chkOcean.checked = preset.modules.ocean;
  ui.chkStream.checked = preset.modules.stream;
  ui.chkFire.checked = preset.modules.fire;
  ui.chkCrickets.checked = preset.modules.crickets;

  updateLabels();
  if (running) syncModuleToggles(true);
  applyMacros();
}

function populateUI(){
  // category select
  ui.selCategory.innerHTML = Object.keys(PRESETS).map(k=>`<option>${k}</option>`).join("");
  ui.selCategory.value = DEFAULT_CATEGORY;
  populatePresets(DEFAULT_CATEGORY);
}

function populatePresets(category){
  const list = PRESETS[category] || [];
  ui.selPreset.innerHTML = list.map((p,i)=>`<option value="${i}">${p.name}</option>`).join("");
  ui.selPreset.value = "0";
  setFromPreset(list[0]);
}

function gentleRandomize(){
  // small random nudges
  const nudge = (el, amt)=>{ el.value = clamp01(+el.value + (Math.random()*2-1)*amt); };
  nudge(ui.rngIntensity, 0.08);
  nudge(ui.rngDensity, 0.10);
  nudge(ui.rngBright, 0.08);
  nudge(ui.rngVar, 0.12);
  nudge(ui.rngDist, 0.10);
  nudge(ui.rngRev, 0.06);
  updateLabels();
  applyMacros();
}

async function start(){
  try {
    await ensureAudio();
    if (ctx.state === "suspended") {
      await ctx.resume();
    }
    
    console.log("Audio context state:", ctx.state);
    console.log("Sample rate:", ctx.sampleRate);

    running=true;
    ui.btnPlay.disabled=true;
    ui.btnPlay.classList.add('playing');
    ui.btnPlay.textContent = '❚❚ Playing';
    ui.btnStop.disabled=false;

    // (Re)build impulse response with current distance-ish
    const m = getMacros();
    convolver.buffer = makeImpulseResponse(ctx, lerp(0.9, 2.0, m.distance), lerp(0.25, 0.55, m.distance));

    syncModuleToggles(false);
    applyMacros();
    
    const activeModules = Object.keys(modules).filter(k => k !== "_bus");
    console.log("Audio started. Active modules:", activeModules);
    console.log("Master gain:", masterGain.gain.value);
    console.log("Selected modules:", selectedModules());
    
    // Verify modules are actually producing sound
    activeModules.forEach(key => {
      const mod = modules[key];
      if (mod) {
        console.log(`${key} module - on: ${mod.on}`);
      }
    });
  } catch (err) {
    console.error("Failed to start audio:", err);
    alert("Failed to start audio: " + err.message + "\n\nPlease check the console for details.");
    running = false;
    ui.btnPlay.disabled = false;
    ui.btnPlay.classList.remove('playing');
    ui.btnPlay.textContent = '▶ Play';
    ui.btnStop.disabled = true;
  }
}

function stop(){
  running=false;
  ui.btnPlay.disabled=false;
  ui.btnPlay.classList.remove('playing');
  ui.btnPlay.textContent = '▶ Play';
  ui.btnStop.disabled=true;

  // stop modules
  Object.keys(modules).forEach(k=>{
    if (k === "_bus") return;
    try{ modules[k].stop(); }catch{}
    delete modules[k];
  });
  // keep bus but disconnect to be safe
  if (modules._bus){
    try{ modules._bus.disconnect(); }catch{}
    modules._bus = null;
  }
}

function onAnyChange(){
  updateLabels();
  if (running){
    applyMacros();
  }
}

function hookup(){
  populateUI();
  updateLabels();

  ui.btnPlay.addEventListener("click", start);
  ui.btnStop.addEventListener("click", stop);

  ui.selCategory.addEventListener("change", ()=>{
    populatePresets(ui.selCategory.value);
  });
  ui.selPreset.addEventListener("change", ()=>{
    const cat = ui.selCategory.value;
    const p = PRESETS[cat][+ui.selPreset.value];
    setFromPreset(p);
  });

  ui.btnRandom.addEventListener("click", gentleRandomize);

  [
    ui.rngMaster,ui.rngIntensity,ui.rngDensity,ui.rngBright,ui.rngVar,ui.rngDist,ui.rngRev,ui.rngXfade
  ].forEach(el=>el.addEventListener("input", onAnyChange));

  [
    ui.chkRain,ui.chkWind,ui.chkOcean,ui.chkStream,ui.chkFire,ui.chkCrickets
  ].forEach(el=>el.addEventListener("change", ()=>{ if (running) syncModuleToggles(true); }));
}

hookup();
</script>
</body>
</html>
